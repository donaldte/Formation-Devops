version: "3.9"  # Version du format Compose (3.9 est stable et moderne)

# Définition des réseaux (un réseau interne pour la com entre services)
networks:
  app_net:
    driver: bridge  # Réseau bridge Docker par défaut, isole les services

# Définition des volumes persistants (données qui survivent aux redémarrages)
volumes:
  postgres_data:  # Volume pour stocker les données PostgreSQL durablement

# Définition d’une configuration de logs commune pour éviter de saturer le disque
x-logging: &default-logging
  driver: "json-file"
  options:
    max-size: "10m"   # Chaque fichier log max 10 Mo
    max-file: "3"     # Conserver seulement 3 fichiers

services:

  # ----------------------
  # Application Web
  # ----------------------
  web:
    container_name: web_app   # Nom du conteneur (optionnel) --scale web=3 pour dupliquer
    build:
      context: .              # Construit l'image depuis le Dockerfile à la racine
      dockerfile: Dockerfile  # Précise le Dockerfile (optionnel si nom par défaut)
      target: dev             # Étape de build (dev ou prod si multi-stage)
    # image: ton-registry/ton-app:1.0.0   # En production, utilise une image versionnée

    restart: unless-stopped   # Redémarre sauf si on l’arrête volontairement
    env_file: .env            # Charge toutes les variables sensibles depuis .env
    command: /entrypoint.sh   # Script de démarrage custom
    depends_on:               # Démarrage conditionnel (avec healthchecks)
      redis:
        condition: service_healthy
      database:
        condition: service_healthy
    healthcheck:              # Vérifie que le service web est bien up
      test: ["CMD-SHELL", "curl -fsS http://localhost:8000/healthz || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 15s
    networks:
      - app_net
    logging: *default-logging

    # Profil DEV : bind mount + accès terminal
    profiles: ["dev"]
    volumes:
      - .:/app    # Monte le code local pour un dev rapide (NE PAS utiliser en prod)
    stdin_open: true
    tty: true

  # ----------------------
  # Redis
  # ----------------------
  redis:
    image: redis:7.2
    restart: unless-stopped
    networks:
      - app_net
    logging: *default-logging
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 5s

    # Options de sécurité (production)
    profiles: ["prod"]
    read_only: true
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL   # Supprime toutes les capacités root inutiles

  # ----------------------
  # PostgreSQL
  # ----------------------
  database:
    image: postgres:15.6
    restart: unless-stopped
    env_file: .env   # Charge DB, USER, PASSWORD depuis .env
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app_net
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB -h localhost"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 20s

    # En dev : expose le port pour se connecter avec un client SQL
    profiles: ["dev"]
    ports:
      - "5432:5432"

    # En prod : sécurité renforcée (pas de port exposé)
    # profiles: ["prod"]
    # read_only: true
    # security_opt:
    #   - no-new-privileges:true
    # cap_drop:
    #   - ALL

  # ----------------------
  # Nginx (reverse proxy / load balancer)
  # ----------------------
  nginx:
    image: nginx:1.25   # Toujours versionner (pas latest)
    restart: unless-stopped
    depends_on:
      web:
        condition: service_healthy
    ports:
      - "80:80"   # Expose en HTTP
      # - "443:443"  # Pour SSL (optionnel)
    volumes:
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      # - ./nginx/certs:/etc/nginx/certs:ro   # Certificats TLS en prod
    networks:
      - app_net
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost/ || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s
